diff --git a/tsk/fs/hfs.c b/tsk/fs/hfs.c
index 00f1720b..889df108 100644
--- a/tsk/fs/hfs.c
+++ b/tsk/fs/hfs.c
@@ -91,6 +91,10 @@
 
 #include "lzvn.h"
 
+#if defined( TSK_WIN32 )
+#define __func__ __FUNCTION__
+#endif
+
 // Forward declarations:
 static uint8_t hfs_load_attrs(TSK_FS_FILE * fs_file);
 static uint8_t hfs_load_extended_attrs(TSK_FS_FILE * file,
@@ -372,10 +376,13 @@ static TSK_FS_ATTR_RUN *
 hfs_extents_to_attr(TSK_FS_INFO * a_fs, const hfs_ext_desc * a_extents,
     TSK_OFF_T a_start_off)
 {
+    TSK_FS_ATTR_RUN *cur_run = NULL;
     TSK_FS_ATTR_RUN *head_run = NULL;
     TSK_FS_ATTR_RUN *prev_run = NULL;
     int i;
     TSK_OFF_T cur_off = a_start_off;
+    uint32_t addr = 0;
+    uint32_t len = 0;
 
     // since tsk_errno is checked as a return value, make sure it is clean.
     tsk_error_reset();
@@ -386,10 +393,8 @@ hfs_extents_to_attr(TSK_FS_INFO * a_fs, const hfs_ext_desc * a_extents,
             " to runlist\n", a_start_off);
 
     for (i = 0; i < 8; ++i) {
-        TSK_FS_ATTR_RUN *cur_run;
-
-        uint32_t addr = tsk_getu32(a_fs->endian, a_extents[i].start_blk);
-        uint32_t len = tsk_getu32(a_fs->endian, a_extents[i].blk_cnt);
+        addr = tsk_getu32(a_fs->endian, a_extents[i].start_blk);
+        len = tsk_getu32(a_fs->endian, a_extents[i].blk_cnt);
 
         if (tsk_verbose)
             tsk_fprintf(stderr,
@@ -443,6 +448,26 @@ hfs_ext_find_extent_record_attr(HFS_INFO * hfs, uint32_t cnid,
     uint8_t is_done;
     uint8_t desiredType;
 
+    ssize_t cnt;
+
+    TSK_OFF_T cur_off;      /* start address of cur_node */
+    uint16_t num_rec;       /* number of records in this node */
+    hfs_btree_node *node_desc;
+
+    uint32_t next_node = 0;
+    int rec;
+
+    int cmp;
+    size_t rec_off;
+    hfs_btree_key_ext *key;
+
+    int keylen;
+
+    uint32_t rec_cnid;
+    hfs_extents *extents;
+    TSK_OFF_T ext_off = 0;
+    TSK_FS_ATTR_RUN *attr_run;
+
     tsk_error_reset();
 
     if (tsk_verbose)
@@ -462,8 +487,6 @@ hfs_ext_find_extent_record_attr(HFS_INFO * hfs, uint32_t cnid,
 
     // Load the extents attribute, if it has not been done so yet.
     if (hfs->extents_file == NULL) {
-        ssize_t cnt;
-
         if ((hfs->extents_file =
                 tsk_fs_file_open_meta(fs, NULL,
                     HFS_EXTENTS_FILE_ID)) == NULL) {
@@ -524,11 +547,6 @@ hfs_ext_find_extent_record_attr(HFS_INFO * hfs, uint32_t cnid,
     /* Recurse down to the needed leaf nodes and then go forward */
     is_done = 0;
     while (is_done == 0) {
-        TSK_OFF_T cur_off;      /* start address of cur_node */
-        uint16_t num_rec;       /* number of records in this node */
-        ssize_t cnt;
-        hfs_btree_node *node_desc;
-
         // sanity check
         if (cur_node > tsk_getu32(fs->endian,
                 hfs->extents_header.totalNodes)) {
@@ -585,8 +603,7 @@ hfs_ext_find_extent_record_attr(HFS_INFO * hfs, uint32_t cnid,
         /* With an index node, find the record with the largest key that is smaller
          * to or equal to cnid */
         if (node_desc->type == HFS_BT_NODE_TYPE_IDX) {
-            uint32_t next_node = 0;
-            int rec;
+            next_node = 0;
 
             if (tsk_verbose)
                 tsk_fprintf(stderr,
@@ -595,10 +612,6 @@ hfs_ext_find_extent_record_attr(HFS_INFO * hfs, uint32_t cnid,
                     cur_off, num_rec);
 
             for (rec = 0; rec < num_rec; ++rec) {
-                int cmp;
-                size_t rec_off;
-                hfs_btree_key_ext *key;
-
                 // get the record offset in the node
                 rec_off =
                     tsk_getu16(fs->endian,
@@ -629,7 +642,7 @@ hfs_ext_find_extent_record_attr(HFS_INFO * hfs, uint32_t cnid,
                 /* save the info from this record unless it is bigger than cnid */
                 if ((cmp <= 0) || (next_node == 0)) {
                     hfs_btree_index_record *idx_rec;
-                    int keylen =
+                    keylen =
                         2 + hfs_get_idxkeylen(hfs, tsk_getu16(fs->endian,
                             key->key_len), &(hfs->extents_header));
                     if (rec_off + keylen > nodesize) {
@@ -667,8 +680,6 @@ hfs_ext_find_extent_record_attr(HFS_INFO * hfs, uint32_t cnid,
 
         /* with a leaf, we process until we are past cnid.  We move right too if we can */
         else if (node_desc->type == HFS_BT_NODE_TYPE_LEAF) {
-            int rec;
-
             if (tsk_verbose)
                 tsk_fprintf(stderr,
                     "hfs_ext_find_extent_record: Leaf node %" PRIu32 " @ %"
@@ -676,13 +687,7 @@ hfs_ext_find_extent_record_attr(HFS_INFO * hfs, uint32_t cnid,
                     num_rec);
 
             for (rec = 0; rec < num_rec; ++rec) {
-                size_t rec_off;
-                hfs_btree_key_ext *key;
-                uint32_t rec_cnid;
-                hfs_extents *extents;
-                TSK_OFF_T ext_off = 0;
-                int keylen;
-                TSK_FS_ATTR_RUN *attr_run;
+                ext_off = 0;
 
                 // get the record offset in the node
                 rec_off =
@@ -843,6 +848,19 @@ hfs_cat_traverse(HFS_INFO * hfs,
     uint16_t nodesize;
     uint8_t is_done = 0;
 
+    TSK_OFF_T cur_off;      /* start address of cur_node */
+    uint16_t num_rec;       /* number of records in this node */
+    ssize_t cnt;
+    hfs_btree_node *node_desc;
+
+    uint32_t next_node = 0;
+    int rec;
+
+    size_t rec_off;
+    hfs_btree_key_cat *key;
+    uint8_t retval;
+    int keylen;
+
     tsk_error_reset();
 
     nodesize = tsk_getu16(fs->endian, hfs->catalog_header.nodesize);
@@ -872,11 +890,6 @@ hfs_cat_traverse(HFS_INFO * hfs,
     /* Recurse down to the needed leaf nodes and then go forward */
     is_done = 0;
     while (is_done == 0) {
-        TSK_OFF_T cur_off;      /* start address of cur_node */
-        uint16_t num_rec;       /* number of records in this node */
-        ssize_t cnt;
-        hfs_btree_node *node_desc;
-
         // sanity check
         if (cur_node > tsk_getu32(fs->endian,
                 hfs->catalog_header.totalNodes)) {
@@ -930,15 +943,9 @@ hfs_cat_traverse(HFS_INFO * hfs,
         /* With an index node, find the record with the largest key that is smaller
          * to or equal to cnid */
         if (node_desc->type == HFS_BT_NODE_TYPE_IDX) {
-            uint32_t next_node = 0;
-            int rec;
+            next_node = 0;
 
             for (rec = 0; rec < num_rec; ++rec) {
-                size_t rec_off;
-                hfs_btree_key_cat *key;
-                uint8_t retval;
-                int keylen;
-
                 // get the record offset in the node
                 rec_off =
                     tsk_getu16(fs->endian,
@@ -991,7 +998,7 @@ hfs_cat_traverse(HFS_INFO * hfs,
                 else if ((retval == HFS_BTREE_CB_IDX_LT)
                     || (next_node == 0)) {
                     hfs_btree_index_record *idx_rec;
-                    int keylen =
+                    keylen =
                         2 + hfs_get_idxkeylen(hfs, tsk_getu16(fs->endian,
                             key->key_len), &(hfs->catalog_header));
                     if (rec_off + keylen > nodesize) {
@@ -1036,14 +1043,7 @@ hfs_cat_traverse(HFS_INFO * hfs,
 
         /* With a leaf, we look for the specific record. */
         else if (node_desc->type == HFS_BT_NODE_TYPE_LEAF) {
-            int rec;
-
             for (rec = 0; rec < num_rec; ++rec) {
-                size_t rec_off;
-                hfs_btree_key_cat *key;
-                uint8_t retval;
-                int keylen;
-
                 // get the record offset in the node
                 rec_off =
                     tsk_getu16(fs->endian,
@@ -1130,7 +1130,10 @@ hfs_cat_get_record_offset_cb(HFS_INFO * hfs, int8_t level_type,
     TSK_OFF_T key_off, void *ptr)
 {
     HFS_CAT_GET_RECORD_OFFSET_DATA *offset_data = (HFS_CAT_GET_RECORD_OFFSET_DATA *)ptr;
-    const hfs_btree_key_cat *targ_key = offset_data->targ_key;
+    const hfs_btree_key_cat *targ_key = NULL;
+    int diff = 0;
+
+    targ_key = offset_data->targ_key;
 
     if (tsk_verbose)
         tsk_fprintf(stderr,
@@ -1141,14 +1144,14 @@ hfs_cat_get_record_offset_cb(HFS_INFO * hfs, int8_t level_type,
             tsk_getu32(hfs->fs_info.endian, cur_key->parent_cnid));
 
     if (level_type == HFS_BT_NODE_TYPE_IDX) {
-        int diff = hfs_cat_compare_keys(hfs, cur_key, targ_key);
+        diff = hfs_cat_compare_keys(hfs, cur_key, targ_key);
         if (diff < 0)
             return HFS_BTREE_CB_IDX_LT;
         else
             return HFS_BTREE_CB_IDX_EQGT;
     }
     else {
-        int diff = hfs_cat_compare_keys(hfs, cur_key, targ_key);
+        diff = hfs_cat_compare_keys(hfs, cur_key, targ_key);
 
         // see if this record is for our file or if we passed the interesting entries
         if (diff < 0) {
@@ -1419,6 +1422,7 @@ hfs_follow_hard_link(HFS_INFO * hfs, hfs_file * cat,
     time_t crtime;
     uint32_t file_type;
     uint32_t file_creator;
+    uint32_t linkNum;
 
     *is_error = 0;              // default, not an error
 
@@ -1457,7 +1461,7 @@ hfs_follow_hard_link(HFS_INFO * hfs, hfs_file * cat,
         // For this to work, we need the FS creation times.  Is at least one of these set?
         if ((!hfs->has_root_crtime) && (!hfs->has_meta_dir_crtime)
             && (!hfs->has_meta_crtime)) {
-            uint32_t linkNum =
+            linkNum =
                 tsk_getu32(fs->endian, cat->std.perm.special.inum);
             *is_error = 1;
             if (tsk_verbose)
@@ -1482,11 +1486,11 @@ hfs_follow_hard_link(HFS_INFO * hfs, hfs_file * cat,
             (hfs->has_meta_dir_crtime && (crtime == hfs->metadir_crtime))
             || (hfs->has_root_crtime && (crtime == hfs->root_crtime))) {
             // OK, this is a hard link to a file.
-            uint32_t linkNum =
+            linkNum =
                 tsk_getu32(fs->endian, cat->std.perm.special.inum);
 
-            // We used to resolve this ID to a file in X folder using hfs_lookup_hard_link, but found 
-            // that it was very ineffecient and always resulted in the same linkNum value. 
+            // We used to resolve this ID to a file in X folder using hfs_lookup_hard_link, but found
+            // that it was very ineffecient and always resulted in the same linkNum value.
             // We now just use linkNum
             return linkNum;
         }
@@ -1504,7 +1508,7 @@ hfs_follow_hard_link(HFS_INFO * hfs, hfs_file * cat,
         // For this to work, we need the FS creation times.  Is at least one of these set?
         if ((!hfs->has_root_crtime) && (!hfs->has_meta_dir_crtime)
             && (!hfs->has_meta_crtime)) {
-            uint32_t linkNum =
+            linkNum =
                 tsk_getu32(fs->endian, cat->std.perm.special.inum);
             *is_error = 1;
 
@@ -1532,11 +1536,11 @@ hfs_follow_hard_link(HFS_INFO * hfs, hfs_file * cat,
             (hfs->has_meta_dir_crtime && (crtime == hfs->metadir_crtime))
             || (hfs->has_root_crtime && (crtime == hfs->root_crtime))) {
             // OK, this is a hard link to a directory.
-            uint32_t linkNum =
+            linkNum =
                 tsk_getu32(fs->endian, cat->std.perm.special.inum);
 
-            // We used to resolve this ID to a file in X folder using hfs_lookup_hard_link, but found 
-            // that it was very ineffecient and always resulted in the same linkNum value. 
+            // We used to resolve this ID to a file in X folder using hfs_lookup_hard_link, but found
+            // that it was very ineffecient and always resulted in the same linkNum value.
             // We now just use linkNum
             return linkNum;
         }
@@ -1568,6 +1572,11 @@ hfs_cat_file_lookup(HFS_INFO * hfs, TSK_INUM_T inum, HFS_ENTRY * entry,
     hfs_file_folder record;     /* file/folder record */
     TSK_OFF_T off;
 
+    unsigned char is_err;
+    TSK_INUM_T target_cnid = 0;
+
+    uint8_t res = 0;
+
     tsk_error_reset();
 
     if (tsk_verbose)
@@ -1690,8 +1699,7 @@ hfs_cat_file_lookup(HFS_INFO * hfs, TSK_INUM_T inum, HFS_ENTRY * entry,
 
     if (follow_hard_link) {
         // TEST to see if this is a hard link
-        unsigned char is_err;
-        TSK_INUM_T target_cnid =
+        target_cnid =
             hfs_follow_hard_link(hfs, &(entry->cat), &is_err);
         if (is_err > 1) {
             error_returned
@@ -1701,7 +1709,7 @@ hfs_cat_file_lookup(HFS_INFO * hfs, TSK_INUM_T inum, HFS_ENTRY * entry,
         }
         if (target_cnid != inum) {
             // This is a hard link, and we have got the cnid of the target file, so look it up.
-            uint8_t res =
+            res =
                 hfs_cat_file_lookup(hfs, target_cnid, entry, FALSE);
             if (res != 0) {
                 error_returned
@@ -1743,13 +1751,15 @@ hfs_find_highest_inum(HFS_INFO * hfs)
 {
     // @@@ get actual number from Catalog file (go to far right) (we can't always trust the vol header)
     TSK_INUM_T inum;
+    TSK_FS_INFO *fs = NULL;
+
     if (hfs_cat_traverse(hfs, hfs_find_highest_inum_cb, &inum)) {
       /* Catalog traversal failed, fallback on legacy method :
          if HFS_VH_ATTR_CNIDS_REUSED is set, then
          the maximum CNID is 2^32-1; if it's not set, then nextCatalogId is
          supposed to be larger than all CNIDs on disk.
        */
-        TSK_FS_INFO *fs = (TSK_FS_INFO *) & (hfs->fs_info);
+        fs = (TSK_FS_INFO *) & (hfs->fs_info);
         if (tsk_getu32(fs->endian, hfs->fs->attr) & HFS_VH_ATTR_CNIDS_REUSED)
             return (TSK_INUM_T) 0xffffffff;
         else
@@ -2341,6 +2351,8 @@ hfs_dinode_copy(HFS_INFO * a_hfs, const HFS_ENTRY * a_hfs_entry,
     uint16_t hfsmode;
     TSK_INUM_T iStd;            // the inum (or CNID) that occurs in the standard file metadata
 
+    ssize_t bytes_read;
+
     if (a_entry == NULL) {
         error_detected(TSK_ERR_FS_ARG,
             "hfs_dinode_copy: a_entry = a_hfs_entry->cat is NULL");
@@ -2480,8 +2492,6 @@ hfs_dinode_copy(HFS_INFO * a_hfs, const HFS_ENTRY * a_hfs_entry,
     if ((a_fs_meta->type == TSK_FS_META_TYPE_LNK) &&
         (a_fs_meta->size >= 0) && (a_fs_meta->size < HFS_MAXPATHLEN)) {
 
-        ssize_t bytes_read;
-
         a_fs_meta->link = tsk_malloc((size_t) a_fs_meta->size + 1);
         if (a_fs_meta->link == NULL)
             return 1;
@@ -2737,6 +2747,10 @@ hfs_read_lzvn_block_table(const TSK_FS_ATTR *rAttr, CMP_OFFSET_ENTRY** offsetTab
     char *offsetTableData = NULL;
     CMP_OFFSET_ENTRY *offsetTable = NULL;
 
+    uint32_t a = 0;
+    uint32_t b;
+    size_t i;
+
     // The offset table is a sequence of 4-byte offsets of compressed
     // blocks. The first 4 bytes is thus the offset of the first block,
     // but also 4 times the number of entries in the table.
@@ -2780,9 +2794,7 @@ hfs_read_lzvn_block_table(const TSK_FS_ATTR *rAttr, CMP_OFFSET_ENTRY** offsetTab
         goto on_error;
     }
 
-    uint32_t a = tableDataSize;
-    uint32_t b;
-    size_t i;
+    a = tableDataSize;
 
     for (i = 0; i < tableSize; ++i) {
         b = tsk_getu32(TSK_LIT_ENDIAN, offsetTableData + 4*(i+1));
@@ -2846,6 +2858,9 @@ static int hfs_decompress_noncompressed_block(char* rawBuf, uint32_t len, char*
  */
 static int hfs_decompress_zlib_block(char* rawBuf, uint32_t len, char* uncBuf, uint64_t* uncLen)
 {
+    unsigned long bytesConsumed;
+    int infResult = 0;
+
     // see if this block is compressed
     if (len > 0 && (rawBuf[0] & 0x0F) != 0x0F) {
         // Uncompress the chunk of data
@@ -2853,8 +2868,7 @@ static int hfs_decompress_zlib_block(char* rawBuf, uint32_t len, char* uncBuf, u
             tsk_fprintf(stderr,
                         "%s: Inflating the compression unit\n", __func__);
 
-        unsigned long bytesConsumed;
-        int infResult = zlib_inflate(rawBuf, (uint64_t) len,
+        infResult = zlib_inflate(rawBuf, (uint64_t) len,
             uncBuf, (uint64_t) COMPRESSION_UNIT_SIZE,
             uncLen, &bytesConsumed);
         if (infResult != 0) {
@@ -2938,6 +2952,10 @@ static ssize_t read_and_decompress_block(
     uint32_t len = offsetTable[indx].length;
     uint64_t uncLen;
 
+    const char *msg = NULL;
+
+    uint32_t expUncLen = 0;
+
     if (tsk_verbose)
         tsk_fprintf(stderr,
             "%s: Reading compression unit %d, length %d\n",
@@ -2962,7 +2980,7 @@ static ssize_t read_and_decompress_block(
     attrReadResult = tsk_fs_attr_read(rAttr, offset,
         rawBuf, len, TSK_FS_FILE_READ_FLAG_NONE);
     if (attrReadResult != (ssize_t) len) {
-        char msg[] =
+        msg =
             "%s%s: reading in the compression offset table, "
             "return value %u should have been %u";
 
@@ -2981,7 +2999,7 @@ static ssize_t read_and_decompress_block(
 
     // If size is a multiple of COMPRESSION_UNIT_SIZE,
     // expected uncompressed length is COMPRESSION_UNIT_SIZE
-    const uint32_t expUncLen = indx == offsetTableSize - 1 ?
+    expUncLen = indx == offsetTableSize - 1 ?
         ((rAttr->fs_file->meta->size - 1) % COMPRESSION_UNIT_SIZE) + 1 :
         COMPRESSION_UNIT_SIZE;
 
@@ -3032,6 +3050,14 @@ hfs_attr_walk_compressed_rsrc(const TSK_FS_ATTR * fs_attr,
     size_t indx;                // index for looping over the offset table
     TSK_OFF_T off = 0;          // the offset in the uncompressed data stream consumed thus far
 
+    ssize_t uncLen;        // uncompressed length
+    unsigned int blockSize;
+    uint64_t lumpSize;
+    uint64_t remaining;
+    char *lumpStart;
+
+    int retval;         // action return value
+
     if (tsk_verbose)
         tsk_fprintf(stderr,
             "%s:  Entered, because this is a compressed file with compressed data in the resource fork\n", __func__);
@@ -3105,12 +3131,6 @@ hfs_attr_walk_compressed_rsrc(const TSK_FS_ATTR * fs_attr,
 
     // FOR entry in the table DO
     for (indx = 0; indx < offsetTableSize; ++indx) {
-        ssize_t uncLen;        // uncompressed length
-        unsigned int blockSize;
-        uint64_t lumpSize;
-        uint64_t remaining;
-        char *lumpStart;
-
         switch ((uncLen = read_and_decompress_block(
                     rAttr, rawBuf, uncBuf,
                     offsetTable, offsetTableSize, offsetTableOffset, indx,
@@ -3131,7 +3151,6 @@ hfs_attr_walk_compressed_rsrc(const TSK_FS_ATTR * fs_attr,
         lumpStart = uncBuf;
 
         while (remaining > 0) {
-            int retval;         // action return value
             lumpSize = remaining <= blockSize ? remaining : blockSize;
 
             // Apply the callback function
@@ -3262,6 +3281,10 @@ hfs_file_read_compressed_rsrc(const TSK_FS_ATTR * a_fs_attr,
     TSK_OFF_T endUnit = 0;
     uint64_t bytesCopied;
 
+    uint64_t uncLen;
+    char *uncBufPtr = NULL;
+    size_t bytesToCopy;
+
     if (tsk_verbose)
         tsk_fprintf(stderr,
             "%s: called because this file is compressed, with data in the resource fork\n", __func__);
@@ -3371,9 +3394,7 @@ hfs_file_read_compressed_rsrc(const TSK_FS_ATTR * a_fs_attr,
 
     // Read from the indicated comp units
     for (indx = startUnit; indx <= endUnit; ++indx) {
-        uint64_t uncLen;
-        char *uncBufPtr = uncBuf;
-        size_t bytesToCopy;
+        uncBufPtr = uncBuf;
 
         switch ((uncLen = read_and_decompress_block(
                     rAttr, rawBuf, uncBuf,
@@ -3521,6 +3542,17 @@ static int hfs_decompress_noncompressed_attr(char* rawBuf, uint32_t rawSize, uin
  */
 static int hfs_decompress_zlib_attr(char* rawBuf, uint32_t rawSize, uint64_t uncSize, char** dstBuf, uint64_t* dstSize, int* dstBufFree)
 {
+#ifdef HAVE_LIBZ
+        char* uncBuf = NULL;
+        uint64_t uLen;
+        unsigned long bytesConsumed;
+        int infResult;
+#else
+        // Dummy is one byte long, so the ptr is not null, but we set the
+        // length to zero bytes, so it is never read.
+        static uint8_t dummy[1];
+#endif
+
     // ZLIB blocks cannot start with 0xF as the low nibble, so that's used
     // as the flag for noncompressed blocks
     if ((rawBuf[0] & 0x0F) == 0x0F) {
@@ -3529,11 +3561,6 @@ static int hfs_decompress_zlib_attr(char* rawBuf, uint32_t rawSize, uint64_t unc
     }
     else {
 #ifdef HAVE_LIBZ
-        char* uncBuf = NULL;
-        uint64_t uLen;
-        unsigned long bytesConsumed;
-        int infResult;
-
         if (tsk_verbose)
             tsk_fprintf(stderr,
                         "%s: Uncompressing (inflating) data.", __func__);
@@ -3577,10 +3604,6 @@ static int hfs_decompress_zlib_attr(char* rawBuf, uint32_t rawSize, uint64_t unc
             tsk_fprintf(stderr,
                         "%s: ZLIB not available, so loading an empty default DATA attribute.\n", __func__);
 
-        // Dummy is one byte long, so the ptr is not null, but we set the
-        // length to zero bytes, so it is never read.
-        static uint8_t dummy[1];
-
         *dstBuf = dummy;
         *dstSize = 0;
         *dstBufFree = FALSE;
@@ -3605,6 +3628,8 @@ static int hfs_decompress_zlib_attr(char* rawBuf, uint32_t rawSize, uint64_t unc
  */
 static int hfs_decompress_lzvn_attr(char* rawBuf, uint32_t rawSize, uint64_t uncSize, char** dstBuf, uint64_t* dstSize, int* dstBufFree)
 {
+    char* uncBuf;
+
     // LZVN blocks cannot start with 0x06, so that's used as the flag for
     // noncompressed blocks
     if (rawBuf[0] == 0x06) {
@@ -3612,7 +3637,7 @@ static int hfs_decompress_lzvn_attr(char* rawBuf, uint32_t rawSize, uint64_t unc
             rawBuf, rawSize, uncSize, dstBuf, dstSize, dstBufFree);
     }
 
-    char* uncBuf = (char *) tsk_malloc((size_t) uncSize);
+    uncBuf = (char *) tsk_malloc((size_t) uncSize);
     *dstSize = lzvn_decode_buffer(uncBuf, uncSize, rawBuf, rawSize);
     *dstBuf = uncBuf;
     *dstBufFree = TRUE;
@@ -3646,6 +3671,12 @@ hfs_file_read_compressed_attr(TSK_FS_FILE* fs_file,
                                                      uint64_t* dstSize,
                                                      int* dstBufFree))
 {
+    TSK_FS_ATTR *fs_attr_unc;
+
+    char* dstBuf;
+    uint64_t dstSize;
+    int dstBufFree = FALSE;
+
     // Data is inline. We will load the uncompressed data as a
     // resident attribute.
     if (tsk_verbose)
@@ -3663,8 +3694,6 @@ hfs_file_read_compressed_attr(TSK_FS_FILE* fs_file,
         return 1;
     }
 
-    TSK_FS_ATTR *fs_attr_unc;
-
     // There is data following the compression record, as there should be.
     if ((fs_attr_unc = tsk_fs_attrlist_getnew(
           fs_file->meta->attr, TSK_FS_ATTR_RES)) == NULL)
@@ -3673,10 +3702,6 @@ hfs_file_read_compressed_attr(TSK_FS_FILE* fs_file,
         return 0;
     }
 
-    char* dstBuf;
-    uint64_t dstSize;
-    int dstBufFree = FALSE;
-
     if (!decompress_attr(buffer + 16, attributeLength - 16, uncSize,
                          &dstBuf, &dstSize, &dstBufFree)) {
         return 0;
@@ -3926,6 +3951,35 @@ hfs_load_extended_attrs(TSK_FS_FILE * fs_file,
     TSK_LIST *nodeIDs_processed = NULL; // Keep track of node IDs to prevent an infinite loop
     ssize_t cnt;                    // count of chars read from file.
 
+    uint16_t numRec;        // Number of records in the node
+    int recIndx;            // index for looping over records
+
+    uint16_t keyLength;
+    int comp;           // comparison result
+    char *compStr;      // comparison result, as a string
+    uint8_t *recData;   // pointer to the data part of the record
+    uint32_t keyFileID;
+
+    uint8_t *recOffsetTblEntry = NULL;
+    uint16_t recOffset = 0;
+
+    uint8_t *recordBytes = NULL;
+
+    hfs_attr_data *attrData;
+    uint32_t attributeLength;
+    uint32_t nameLength;
+    uint32_t recordType;
+    int conversionResult;
+    char nameBuff[HFS_MAX_ATTR_NAME_LEN_UTF8_B+1];
+    TSK_FS_ATTR_TYPE_ENUM attrType;
+    TSK_FS_ATTR *fs_attr;   // Points to the attribute to be loaded.
+
+    DECMPFS_DISK_HEADER *cmph = NULL;
+
+    uint64_t uncSize = 0;
+
+    uint32_t newNodeID = 0;
+
     tsk_error_reset();
 
     // The CNID (or inode number) of the file
@@ -3988,9 +4042,6 @@ hfs_load_extended_attrs(TSK_FS_FILE * fs_file,
 
     // While loop, over nodes in path from root node to the correct LEAF node.
     while (1) {
-        uint16_t numRec;        // Number of records in the node
-        int recIndx;            // index for looping over records
-
         if (tsk_verbose) {
             tsk_fprintf(stderr,
                 "hfs_load_extended_attrs: Reading Attributes File node with ID %"
@@ -4056,15 +4107,9 @@ hfs_load_extended_attrs(TSK_FS_FILE * fs_file,
         }
 
         for (recIndx = 0; recIndx < numRec; ++recIndx) {
-            uint16_t keyLength;
-            int comp;           // comparison result
-            char *compStr;      // comparison result, as a string
-            uint8_t *recData;   // pointer to the data part of the record
-            uint32_t keyFileID;
-
             // The offset to the record is stored in table at end of node
-            uint8_t *recOffsetTblEntry = &nodeData[attrFile.nodeSize - (2 * (recIndx + 1))];  // data describing where this record is
-            uint16_t recOffset = tsk_getu16(endian, recOffsetTblEntry);
+            recOffsetTblEntry = &nodeData[attrFile.nodeSize - (2 * (recIndx + 1))];  // data describing where this record is
+            recOffset = tsk_getu16(endian, recOffsetTblEntry);
             //uint8_t * nextRecOffsetData = &nodeData[attrFile.nodeSize - 2* (recIndx+2)];
 
             // make sure the record and first fields are in the buffer
@@ -4075,7 +4120,7 @@ hfs_load_extended_attrs(TSK_FS_FILE * fs_file,
             }
 
             // Pointer to first byte of record
-            uint8_t *recordBytes = &nodeData[recOffset];
+            recordBytes = &nodeData[recOffset];
 
 
             // Cast that to the Attributes file key (n.b., the key is the first thing in the record)
@@ -4160,9 +4205,6 @@ hfs_load_extended_attrs(TSK_FS_FILE * fs_file,
     // Loop over successive LEAF nodes, starting with this one
     done = FALSE;
     while (!done) {
-        uint16_t numRec;        // number of records
-        unsigned int recIndx;            // index for looping over records
-
         if (tsk_verbose)
             tsk_fprintf(stderr,
                 "hfs_load_extended_attrs: Attributes File LEAF Node %"
@@ -4174,12 +4216,8 @@ hfs_load_extended_attrs(TSK_FS_FILE * fs_file,
         for (recIndx = 0; recIndx < numRec; ++recIndx) {
 
             // The offset to the record is stored in table at end of node
-            uint8_t *recOffsetTblEntry = &nodeData[attrFile.nodeSize - (2 * (recIndx + 1))];  // data describing where this record is
-            uint16_t recOffset = tsk_getu16(endian, recOffsetTblEntry);
-
-            int comp;           // comparison result
-            char *compStr;      // comparison result as a string
-            uint32_t keyFileID;
+            recOffsetTblEntry = &nodeData[attrFile.nodeSize - (2 * (recIndx + 1))];  // data describing where this record is
+            recOffset = tsk_getu16(endian, recOffsetTblEntry);
 
             // make sure the record and first fields are in the buffer
             if (recOffset + 14 > attrFile.nodeSize) {
@@ -4189,7 +4227,7 @@ hfs_load_extended_attrs(TSK_FS_FILE * fs_file,
             }
 
             // Pointer to first byte of record
-            uint8_t *recordBytes = &nodeData[recOffset];
+            recordBytes = &nodeData[recOffset];
 
             // Cast that to the Attributes file key
             keyB = (hfs_btree_key_attr *) recordBytes;
@@ -4220,17 +4258,6 @@ hfs_load_extended_attrs(TSK_FS_FILE * fs_file,
             if (comp == 0) {
                 // Yes, so load this attribute
 
-                uint8_t *recData;       // pointer to the data part of the recordBytes
-                hfs_attr_data *attrData;
-                uint32_t attributeLength;
-                uint32_t nameLength;
-                uint32_t recordType;
-                uint16_t keyLength;
-                int conversionResult;
-                char nameBuff[HFS_MAX_ATTR_NAME_LEN_UTF8_B+1];
-                TSK_FS_ATTR_TYPE_ENUM attrType;
-                TSK_FS_ATTR *fs_attr;   // Points to the attribute to be loaded.
-
                 keyLength = tsk_getu16(endian, keyB->key_len);
                 // make sure the fields we care about are still in the buffer
                 // +2 because key_len doesn't include its own length
@@ -4318,10 +4345,10 @@ hfs_load_extended_attrs(TSK_FS_FILE * fs_file,
                 if (strcmp(nameBuff, "com.apple.decmpfs") == 0 &&
                     tsk_getu32(endian, attrData->record_type) == HFS_ATTR_RECORD_INLINE_DATA) {
                     // Now, look at the compression record
-                    DECMPFS_DISK_HEADER *cmph = (DECMPFS_DISK_HEADER *) buffer;
+                    cmph = (DECMPFS_DISK_HEADER *) buffer;
                     *cmpType =
                         tsk_getu32(TSK_LIT_ENDIAN, cmph->compression_type);
-                    uint64_t uncSize = tsk_getu64(TSK_LIT_ENDIAN,
+                    uncSize = tsk_getu64(TSK_LIT_ENDIAN,
                         cmph->uncompressed_size);
 
                     if (tsk_verbose)
@@ -4418,7 +4445,7 @@ hfs_load_extended_attrs(TSK_FS_FILE * fs_file,
             // so we must get the next node, and continue.
 
             // First determine the nodeID of the next LEAF node
-            uint32_t newNodeID = tsk_getu32(endian, nodeDescriptor->flink);
+            newNodeID = tsk_getu32(endian, nodeDescriptor->flink);
 
             //fprintf(stdout, "Next Node ID = %u\n",  newNodeID);
             if (tsk_verbose)
@@ -4543,6 +4570,21 @@ hfs_parse_resource_fork(TSK_FS_FILE * fs_file)
     hfs_resource_type_list_item *tlItem;
     int mindx;                  // index for looping over resource types
 
+    uint16_t numRes;
+    uint16_t refOff;
+    int pindx;              // index for looping over resources
+    uint16_t rID;
+    uint32_t rOffset;
+
+    int16_t nameOffset;
+    char *nameBuffer;
+    RES_DESCRIPTOR *rsrc;
+    char lenBuff[4];    // first 4 bytes of a resource encodes its length
+    uint32_t rLen;      // Resource length
+
+    char *name = NULL;
+    uint8_t nameLen = 0;
+
     if (fs_file == NULL) {
         error_detected(TSK_ERR_FS_ARG,
             "hfs_parse_resource_fork: null fs_file");
@@ -4657,24 +4699,12 @@ hfs_parse_resource_fork(TSK_FS_FILE * fs_file)
     numTypes = tsk_getu16(fs_info->endian, typeList->typeCount) + 1;
 
     for (mindx = 0; mindx < numTypes; ++mindx) {
-        uint16_t numRes;
-        uint16_t refOff;
-        int pindx;              // index for looping over resources
-        uint16_t rID;
-        uint32_t rOffset;
-
         tlItem = &(typeList->type[mindx]);
         numRes = tsk_getu16(fs_info->endian, tlItem->count) + 1;
         refOff = tsk_getu16(fs_info->endian, tlItem->offset);
 
 
         for (pindx = 0; pindx < numRes; ++pindx) {
-            int16_t nameOffset;
-            char *nameBuffer;
-            RES_DESCRIPTOR *rsrc;
-            char lenBuff[4];    // first 4 bytes of a resource encodes its length
-            uint32_t rLen;      // Resource length
-
             hfs_resource_refListItem *item =
                 ((hfs_resource_refListItem *) (((uint8_t *) typeList) +
                     refOff)) + pindx;
@@ -4682,8 +4712,8 @@ hfs_parse_resource_fork(TSK_FS_FILE * fs_file)
             nameBuffer = NULL;
 
             if (hasNameList && nameOffset != -1) {
-                char *name = nameListBegin + nameOffset;
-                uint8_t nameLen = (uint8_t) name[0];
+                name = nameListBegin + nameOffset;
+                nameLen = (uint8_t) name[0];
                 nameBuffer = tsk_malloc(nameLen + 1);
                 if (nameBuffer == NULL) {
                     error_returned
@@ -5207,6 +5237,9 @@ hfs_block_walk(TSK_FS_INFO * fs, TSK_DADDR_T start_blk,
     TSK_FS_BLOCK *fs_block;
     TSK_DADDR_T addr;
 
+    int retval;
+    int myflags;
+
     if (tsk_verbose)
         tsk_fprintf(stderr,
             "%s: start_blk: %" PRIuDADDR " end_blk: %"
@@ -5256,9 +5289,6 @@ hfs_block_walk(TSK_FS_INFO * fs, TSK_DADDR_T start_blk,
      * Iterate
      */
     for (addr = start_blk; addr <= end_blk; ++addr) {
-        int retval;
-        int myflags;
-
         /* identify if the block is allocated or not */
         myflags = hfs_block_is_alloc(hfs, addr) ?
             TSK_FS_BLOCK_FLAG_ALLOC : TSK_FS_BLOCK_FLAG_UNALLOC;
@@ -5303,6 +5333,8 @@ hfs_inode_walk(TSK_FS_INFO * fs, TSK_INUM_T start_inum,
     TSK_INUM_T inum;
     TSK_FS_FILE *fs_file;
 
+    int retval;
+
     if (tsk_verbose)
         tsk_fprintf(stderr,
             "hfs_inode_walk: start_inum: %" PRIuINUM " end_inum: %"
@@ -5360,8 +5392,6 @@ hfs_inode_walk(TSK_FS_INFO * fs, TSK_INUM_T start_inum,
         XSWAP(start_inum, end_inum);
 
     for (inum = start_inum; inum <= end_inum; ++inum) {
-        int retval;
-
         if (hfs_inode_lookup(fs, fs_file, inum)) {
             // deleted files may not exist in the catalog
             if (tsk_error_get_errno() == TSK_ERR_FS_INODE_NUM) {
@@ -5872,6 +5902,34 @@ hfs_istat(TSK_FS_INFO * fs, TSK_FS_ISTAT_FLAG_ENUM istat_flags, FILE * hFile, TS
     const TSK_FS_ATTR *compressionAttr = NULL;
     RES_DESCRIPTOR *rd;         // descriptor of a resource
 
+    int rslt;
+
+    hfs_uni_str *nm = NULL;
+    char name_buf[HFS_MAXNAMLEN + 1];
+    TSK_INUM_T par_cnid;    // parent CNID
+
+    int instr = 0;
+    int drstr = 0;
+
+    int windx;          // loop index
+
+    uint8_t cu = 0;
+
+    int cnt, i;
+
+    const char *type;   // type of the attribute as a string
+    const TSK_FS_ATTR *fs_attr = NULL;
+
+    int attrReadResult;
+    DECMPFS_DISK_HEADER *cmph;
+    uint32_t cmpType;
+    uint64_t uncSize;
+    uint64_t cmpSize = 0;
+
+    char *aBuf = NULL;
+
+    uint32_t off = 0;
+
     tsk_error_reset();
 
     if (tsk_verbose)
@@ -5885,7 +5943,6 @@ hfs_istat(TSK_FS_INFO * fs, TSK_FS_ISTAT_FLAG_ENUM istat_flags, FILE * hFile, TS
     }
 
     if (inum >= HFS_FIRST_USER_CNID) {
-        int rslt;
         tsk_fprintf(hFile, "File Path: ");
         rslt = print_parent_path(hFile, fs, inum);
         if (rslt != 0)
@@ -5927,9 +5984,7 @@ hfs_istat(TSK_FS_INFO * fs, TSK_FS_ISTAT_FLAG_ENUM istat_flags, FILE * hFile, TS
     tsk_fprintf(hFile, "Link count:\t%d\n", fs_file->meta->nlink);
 
     if (hfs_cat_file_lookup(hfs, inum, &entry, TRUE) == 0) {
-        hfs_uni_str *nm = &entry.thread.name;
-        char name_buf[HFS_MAXNAMLEN + 1];
-        TSK_INUM_T par_cnid;    // parent CNID
+        nm = &entry.thread.name;
 
         tsk_fprintf(hFile, "\n");
         hfs_UTF16toUTF8(fs, nm->unicode, (int) tsk_getu16(fs->endian,
@@ -5941,8 +5996,8 @@ hfs_istat(TSK_FS_INFO * fs, TSK_FS_ISTAT_FLAG_ENUM istat_flags, FILE * hFile, TS
         par_cnid = tsk_getu32(fs->endian, &(entry.thread.parent_cnid));
         if ((hfs->has_meta_dir_crtime && par_cnid == hfs->meta_dir_inum) ||
             (hfs->has_meta_crtime && par_cnid == hfs->meta_inum)) {
-            int instr = strncmp(name_buf, "iNode", 5);
-            int drstr = strncmp(name_buf, "dir_", 4);
+            instr = strncmp(name_buf, "iNode", 5);
+            drstr = strncmp(name_buf, "dir_", 4);
 
             if (instr == 0 &&
                 hfs->has_meta_crtime && par_cnid == hfs->meta_inum) {
@@ -6016,13 +6071,12 @@ hfs_istat(TSK_FS_INFO * fs, TSK_FS_ISTAT_FLAG_ENUM istat_flags, FILE * hFile, TS
 
         // File_type and file_cr are not relevant for Folders
         if ( !TSK_FS_IS_DIR_META(fs_file->meta->type)){
-            int windx;          // loop index
             tsk_fprintf(hFile,
                 "File type:\t%04" PRIx32 "  ",
                 tsk_getu32(fs->endian, entry.cat.std.u_info.file_type));
 
             for (windx = 0; windx < 4; ++windx) {
-                uint8_t cu = entry.cat.std.u_info.file_type[windx];
+                cu = entry.cat.std.u_info.file_type[windx];
                 if (cu >= 32 && cu <= 126)
                     tsk_fprintf(hFile, "%c", (char) cu);
                 else
@@ -6033,7 +6087,7 @@ hfs_istat(TSK_FS_INFO * fs, TSK_FS_ISTAT_FLAG_ENUM istat_flags, FILE * hFile, TS
                 "File creator:\t%04" PRIx32 "  ",
                 tsk_getu32(fs->endian, entry.cat.std.u_info.file_cr));
             for (windx = 0; windx < 4; ++windx) {
-                uint8_t cu = entry.cat.std.u_info.file_cr[windx];
+                cu = entry.cat.std.u_info.file_cr[windx];
                 if (cu >= 32 && cu <= 126)
                     tsk_fprintf(hFile, "%c", (char) cu);
                 else
@@ -6188,13 +6242,10 @@ hfs_istat(TSK_FS_INFO * fs, TSK_FS_ISTAT_FLAG_ENUM istat_flags, FILE * hFile, TS
     /* Print all of the attributes */
     tsk_fprintf(hFile, "\nAttributes: \n");
     if (fs_file->meta->attr) {
-        int cnt, i;
-
         // cycle through the attributes
         cnt = tsk_fs_file_attr_getsize(fs_file);
         for (i = 0; i < cnt; ++i) {
-            const char *type;   // type of the attribute as a string
-            const TSK_FS_ATTR *fs_attr =
+            fs_attr =
                 tsk_fs_file_attr_get_idx(fs_file, i);
             if (!fs_attr)
                 continue;
@@ -6272,16 +6323,12 @@ hfs_istat(TSK_FS_INFO * fs, TSK_FS_ISTAT_FLAG_ENUM istat_flags, FILE * hFile, TS
 
     // IF this is a compressed file
     if (compressionAttr != NULL) {
-        const TSK_FS_ATTR *fs_attr = compressionAttr;
-        ssize_t attrReadResult;
-        DECMPFS_DISK_HEADER *cmph;
-        uint32_t cmpType;
-        uint64_t uncSize;
-        uint64_t cmpSize = 0;
+        fs_attr = compressionAttr;
+        cmpSize = 0;
 
         // Read the attribute.  It cannot be too large because it is stored in
         // a btree node
-        char *aBuf = (char *) tsk_malloc((size_t) fs_attr->size);
+        aBuf = (char *) tsk_malloc((size_t) fs_attr->size);
         if (aBuf == NULL) {
             error_returned("hfs_istat: space for a compression attribute");
             return 1;
@@ -6313,7 +6360,7 @@ hfs_istat(TSK_FS_INFO * fs, TSK_FS_ISTAT_FLAG_ENUM istat_flags, FILE * hFile, TS
             // Data is inline
             {
                 // size of header, with indicator byte if uncompressed
-                uint32_t off = (cmph->attr_bytes[0] & 0x0F) == 0x0F ? 17 : 16;
+                off = (cmph->attr_bytes[0] & 0x0F) == 0x0F ? 17 : 16;
                 cmpSize = fs_attr->size - off;
 
                 tsk_fprintf(hFile,
@@ -6327,7 +6374,7 @@ hfs_istat(TSK_FS_INFO * fs, TSK_FS_ISTAT_FLAG_ENUM istat_flags, FILE * hFile, TS
             // Data is inline
             {
                 // size of header, with indicator byte if uncompressed
-                uint32_t off = cmph->attr_bytes[0] == 0x06 ? 17 : 16;
+                off = cmph->attr_bytes[0] == 0x06 ? 17 : 16;
                 cmpSize = fs_attr->size - off;
 
                 tsk_fprintf(hFile,
@@ -6468,6 +6515,15 @@ hfs_open(TSK_IMG_INFO * img_info, TSK_OFF_T offset,
     TSK_INUM_T inum;            // The inum (or CNID) of the metadata directories
     int8_t result;              // of tsk_fs_path2inum()
 
+    hfs_mdb *wrapper_sb = NULL;
+
+    TSK_FS_INFO *fs_info2;
+    uint16_t drAlBlSt = 0;
+    uint32_t drAlBlkSiz = 0;
+    uint16_t startBlock = 0;
+
+    TSK_OFF_T hfsplus_offset = 0;
+
     tsk_error_reset();
 
     if (TSK_FS_TYPE_ISHFS(ftype) == 0) {
@@ -6529,7 +6585,7 @@ hfs_open(TSK_IMG_INFO * img_info, TSK_OFF_T offset,
      */
     if (tsk_getu16(fs->endian, hfs->fs->signature) == HFS_VH_SIG_HFS) {
 
-        hfs_mdb *wrapper_sb = (hfs_mdb *) hfs->fs;
+        wrapper_sb = (hfs_mdb *) hfs->fs;
 
         // Verify that we are setting a wrapper and not a normal HFS volume
         if ((tsk_getu16(fs->endian,
@@ -6537,24 +6593,23 @@ hfs_open(TSK_IMG_INFO * img_info, TSK_OFF_T offset,
             || (tsk_getu16(fs->endian,
                     wrapper_sb->drEmbedSigWord) == HFS_VH_SIG_HFSX)) {
 
-            TSK_FS_INFO *fs_info2;
             // offset in sectors to start of first HFS block
-            uint16_t drAlBlSt =
+            drAlBlSt =
                 tsk_getu16(fs->endian, wrapper_sb->drAlBlSt);
 
             // size of each HFS block
-            uint32_t drAlBlkSiz =
+            drAlBlkSiz =
                 tsk_getu32(fs->endian, wrapper_sb->drAlBlkSiz);
 
             // start of embedded FS
-            uint16_t startBlock = tsk_getu16(fs->endian,
+            startBlock = tsk_getu16(fs->endian,
                 wrapper_sb->drEmbedExtent_startBlock);
 
             // calculate the offset; 512 here is intentional.
             // TN1150 says "The drAlBlSt field contains the offset, in
             // 512-byte blocks, of the wrapper's allocation block 0 relative
             // to the start of the volume"
-            TSK_OFF_T hfsplus_offset =
+            hfsplus_offset =
                 (drAlBlSt * (TSK_OFF_T) 512) +
                 (drAlBlkSiz * (TSK_OFF_T) startBlock);
 
@@ -6884,25 +6939,29 @@ hfs_open(TSK_IMG_INFO * img_info, TSK_OFF_T offset,
 void
 error_detected(uint32_t errnum, char *errstr, ...)
 {
+    TSK_ERROR_INFO *errInfo;
+    char *loc_errstr;
+    size_t sl;
+
     va_list args;
 
     va_start(args, errstr);
 
     {
-        TSK_ERROR_INFO *errInfo = tsk_error_get_info();
-        char *loc_errstr = errInfo->errstr;
+        errInfo = tsk_error_get_info();
+        loc_errstr = errInfo->errstr;
 
         if (errInfo->t_errno == 0)
             errInfo->t_errno = errnum;
         else {
             //This should not happen!  We don't want to wipe out the existing error
             //code, so we write the new code into the error string, in hex.
-            size_t sl = strlen(errstr);
+            sl = strlen(errstr);
             snprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                 " Next errnum: 0x%x ", errnum);
         }
         if (errstr != NULL) {
-            size_t sl = strlen(loc_errstr);
+            sl = strlen(loc_errstr);
             vsnprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                 errstr, args);
         }
@@ -6924,17 +6983,21 @@ error_detected(uint32_t errnum, char *errstr, ...)
 void
 error_returned(char *errstr, ...)
 {
+    TSK_ERROR_INFO *errInfo;
+    char *loc_errstr2;
+    size_t sl;
+
     va_list args;
     va_start(args, errstr);
 
     {
-        TSK_ERROR_INFO *errInfo = tsk_error_get_info();
-        char *loc_errstr2 = errInfo->errstr2;
+        errInfo = tsk_error_get_info();
+        loc_errstr2 = errInfo->errstr2;
 
         if (errInfo->t_errno == 0)
             errInfo->t_errno = TSK_ERR_AUX_GENERIC;
         if (errstr != NULL) {
-            size_t sl = strlen(loc_errstr2);
+            sl = strlen(loc_errstr2);
             vsnprintf(loc_errstr2 + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                 errstr, args);
         }
